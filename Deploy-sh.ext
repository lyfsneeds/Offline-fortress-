# inside your functions folder (or project root if you use mono-repo)
npm install twilio geofire-commonfirebase deploy --only functions
firebase functions:config:set \
  twilio.sid="ACxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" \
  twilio.token="your_auth_token" \
  twilio.api_key="SKxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" \
  twilio.api_secret="your_api_secret" \
  google.perspective_api_key="AIxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
// ============================================================================
// 1.  DISTANCE HELPERS
// ============================================================================

/**
 * Haversine distance in km.
 * R = 6371  => kilometres
 * R = 3959  => miles
 */
export function calculateDistance(
  lat1: number,
  lon1: number,
  lat2: number,
  lon3: number,
  R = 6371
): number {
  const toRad = (d: number) => (d * Math.PI) / 180;
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) ** 2 +
    Math.cos(toRad(lat1)) *
      Math.cos(toRad(lat2)) *
      Math.sin(dLon / 2) ** 2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

// ============================================================================
// 2.  ATTENTION ALERTS â€“ CREATE & NOTIFY
// ============================================================================

export const createAttentionAlert = functions.https.onCall(
  async (data, context) => {
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'Must be signed in'
      );
    }

    const { title, description, lat, lng } = data;

    // 1. Moderate
    const toxicity = await moderateText(`${title} ${description}`);
    if (toxicity > 0.7) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'Content flagged for review'
      );
    }

    // 2. Persist
    const alertSnap = await db.collection('alerts').add({
      userId: context.auth!.uid,
      title,
      description,
      location: new admin.firestore.GeoPoint(lat, lng),
      geohash: geohash.encode(lat, lng, 6),
      active: true,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      responses: []
    });

    // 3. Push to nearby
    await notifyNearbyUsers(lat, lng, 5, {
      title: 'ðŸ†˜ Help Needed Nearby',
      body: `${title} â€“ ${calculateDistance(lat, lng, lat, lng).toFixed(
        1
      )} mi away`,
      data: { alertId: alertSnap.id, type: 'alert' }
    });

    return { alertId: alertSnap.id };
  }
);

/** Push notification to every user whose geohash prefix overlaps the radius. */
async function notifyNearbyUsers(
  lat: number,
  lng: number,
  radiusKm: number,
  payload: { title: string; body: string; data: Record<string, string> }
): Promise<void> {
  const hashes = getGeohashesForRadius(lat, lng, radiusKm); // <= 10 for 'in' query
  if (!hashes.length) return;

  const snap = await db
    .collection('users')
    .where('geohash', 'in', hashes.slice(0, 10))
    .where('notificationsEnabled', '==', true)
    .get();

  const tokens = snap.docs
    .map((d) => d.data().fcmToken)
    .filter((t: string) => t);

  if (tokens.length) {
    await admin.messaging().sendMulticast({
      tokens,
      notification: { title: payload.title, body: payload.body },
      data: payload.data
    });
  }
}

/** Simple toxicity check via Google Perspective. */
async function moderateText(text: string): Promise<number> {
  try {
    const { data } = await axios.post(
      'https://commentanalyzer.googleapis.com/v1alpha1/comments:analyze',
      {
        comment: { text },
        languages: ['en'],
        requestedAttributes: { TOXICITY: {} }
      },
      { params: { key: functions.config().google.perspective_api_key } }
    );
    return data.attributeScores.TOXICITY.summaryScore.value;
  } catch (e) {
    functions.logger.error('Perspective API error', e);
    return 0; // fail-open
  }
}

// ============================================================================
// 3.  TWILIO â€“ ROOM CREATION & ACCESS TOKENS
// ============================================================================

const twilioClient = twilio(
  functions.config().twilio.sid,
  functions.config().twilio.token
);

/**
 * Callable: create a Twilio room and return the token the caller needs
 * to join it.  The callee receives a push with the same roomSid so
 * they can request their own token (see getTwilioToken below).
 */
export const initiateCall = functions.https.onCall(
  async (data, context) => {
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'Must be signed in'
      );
    }

    const { recipientUid, type } = data; // 'voice' | 'video'
    const callerUid = context.auth.uid;

    const callerDoc = await db.collection('users').doc(callerUid).get();
    const recipientDoc = await db.collection('users').doc(recipientUid).get();

    if (!recipientDoc.exists) {
      throw new functions.https.HttpsError('not-found', 'Recipient not found');
    }

    // 1. Create a room
    const room = await twilioClient.video.v1.rooms.create({
      uniqueName: `call_${callerUid}_${recipientUid}_${Date.now()}`,
      type: type === 'video' ? 'group' : 'peer-to-peer',
      recordParticipantsOnConnect: true,
      maxParticipants: 2
    });

    // 2. Give the caller an access token
    const callerToken = makeTwilioToken(callerUid, room.sid);

    // 3. Notify the callee via FCM
    const recipientToken = recipientDoc.data()?.fcmToken;
    if (recipientToken) {
      await admin.messaging().send({
        token: recipientToken,
        data: {
          type: 'incoming_call',
          roomSid: room.sid,
          callerName: callerDoc.data()?.displayName || 'Someone',
          callType: type
        },
        notification: {
          title: 'Incoming call',
          body: `${
            callerDoc.data()?.displayName || 'Someone'
          } is calling (${type})`
        }
      });
    }

    return { roomSid: room.sid, token: callerToken };
  }
);

/**
 * Callable: any authenticated user can exchange a roomSid for an
 * access token (callee uses this after receiving the FCM).
 */
export const getTwilioToken = functions.https.onCall(
  async (data, context) => {
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'Must be signed in'
      );
    }
    const { roomSid } = data;
    return { token: makeTwilioToken(context.auth.uid, roomSid) };
  }
);

/** Helper â€“ generate a Twilio Video grant + JWT */
function makeTwilioToken(identity: string, roomSid: string): string {
  const token = new AccessToken(
    functions.config().twilio.sid,
    functions.config().twilio.api_key,
    functions.config().twilio.api_secret,
    { identity }
  );
  const grant = new VideoGrant({ room: roomSid });
  token.addGrant(grant);
  return token.toJwt();
}

// ============================================================================
// 4.  CLEAN-UP EMPTY ROOMS
// ============================================================================

/** Scheduled every 5 min â€“ closes Twilio rooms that have 0 participants. */
export const closeEmptyRooms = functions.pubsub
  .schedule('every 5 minutes')
  .onRun(async () => {
    const rooms = await twilioClient.video.v1.rooms.list({
      status: 'in-progress'
    });
    await Promise.all(
      rooms
        .filter((r) => r.uniqueName.startsWith('call_'))
        .map(async (r) => {
          const participants = await twilioClient.video.v1
            .rooms(r.sid)
            .participants.list();
          if (participants.length === 0) {
            await twilioClient.video.v1.rooms(r.sid).update({ status: 'completed' });
          }
        })
    );
  });

// ============================================================================
// 5.  GEOHASH UTIL (used by notifyNearbyUsers)
// ============================================================================

/**
 * Return an *approximate* set of geohash prefixes that cover a circle
 * of radiusKm around (lat,lng).  Precision = 6 gives ~1.2 km boxes.
 */
function getGeohashesForRadius(
  lat: number,
  lng: number,
  radiusKm: number
): string[] {
  const precision = 6;
  const centre = geohash.encode(lat, lng, precision);

  // 8-neighbour + centre gives a 3Ã—3 grid â€“ good enough for small radii
  return [centre, ...geohash.neighbours(centre)];
}
// ============================================================================
// 1.  DISTANCE HELPERS
// ============================================================================

/**
 * Haversine distance in km.
 * R = 6371  => kilometres
 * R = 3959  => miles
 */
export function calculateDistance(
  lat1: number,
  lon1: number,
  lat2: number,
  lon3: number,
  R = 6371
): number {
  const toRad = (d: number) => (d * Math.PI) / 180;
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) ** 2 +
    Math.cos(toRad(lat1)) *
      Math.cos(toRad(lat2)) *
      Math.sin(dLon / 2) ** 2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

// ============================================================================
// 2.  ATTENTION ALERTS â€“ CREATE & NOTIFY
// ============================================================================

export const createAttentionAlert = functions.https.onCall(
  async (data, context) => {
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'Must be signed in'
      );
    }

    const { title, description, lat, lng } = data;

    // 1. Moderate
    const toxicity = await moderateText(`${title} ${description}`);
    if (toxicity > 0.7) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'Content flagged for review'
      );
    }

    // 2. Persist
    const alertSnap = await db.collection('alerts').add({
      userId: context.auth!.uid,
      title,
      description,
      location: new admin.firestore.GeoPoint(lat, lng),
      geohash: geohash.encode(lat, lng, 6),
      active: true,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      responses: []
    });

    // 3. Push to nearby
    await notifyNearbyUsers(lat, lng, 5, {
      title: 'ðŸ†˜ Help Needed Nearby',
      body: `${title} â€“ ${calculateDistance(lat, lng, lat, lng).toFixed(
        1
      )} mi away`,
      data: { alertId: alertSnap.id, type: 'alert' }
    });

    return { alertId: alertSnap.id };
  }
);

/** Push notification to every user whose geohash prefix overlaps the radius. */
async function notifyNearbyUsers(
  lat: number,
  lng: number,
  radiusKm: number,
  payload: { title: string; body: string; data: Record<string, string> }
): Promise<void> {
  const hashes = getGeohashesForRadius(lat, lng, radiusKm); // <= 10 for 'in' query
  if (!hashes.length) return;

  const snap = await db
    .collection('users')
    .where('geohash', 'in', hashes.slice(0, 10))
    .where('notificationsEnabled', '==', true)
    .get();

  const tokens = snap.docs
    .map((d) => d.data().fcmToken)
    .filter((t: string) => t);

  if (tokens.length) {
    await admin.messaging().sendMulticast({
      tokens,
      notification: { title: payload.title, body: payload.body },
      data: payload.data
    });
  }
}

/** Simple toxicity check via Google Perspective. */
async function moderateText(text: string): Promise<number> {
  try {
    const { data } = await axios.post(
      'https://commentanalyzer.googleapis.com/v1alpha1/comments:analyze',
      {
        comment: { text },
        languages: ['en'],
        requestedAttributes: { TOXICITY: {} }
      },
      { params: { key: functions.config().google.perspective_api_key } }
    );
    return data.attributeScores.TOXICITY.summaryScore.value;
  } catch (e) {
    functions.logger.error('Perspective API error', e);
    return 0; // fail-open
  }
}

// ============================================================================
// 3.  TWILIO â€“ ROOM CREATION & ACCESS TOKENS
// ============================================================================

const twilioClient = twilio(
  functions.config().twilio.sid,
  functions.config().twilio.token
);

/**
 * Callable: create a Twilio room and return the token the caller needs
 * to join it.  The callee receives a push with the same roomSid so
 * they can request their own token (see getTwilioToken below).
 */
export const initiateCall = functions.https.onCall(
  async (data, context) => {
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'Must be signed in'
      );
    }

    const { recipientUid, type } = data; // 'voice' | 'video'
    const callerUid = context.auth.uid;

    const callerDoc = await db.collection('users').doc(callerUid).get();
    const recipientDoc = await db.collection('users').doc(recipientUid).get();

    if (!recipientDoc.exists) {
      throw new functions.https.HttpsError('not-found', 'Recipient not found');
    }

    // 1. Create a room
    const room = await twilioClient.video.v1.rooms.create({
      uniqueName: `call_${callerUid}_${recipientUid}_${Date.now()}`,
      type: type === 'video' ? 'group' : 'peer-to-peer',
      recordParticipantsOnConnect: true,
      maxParticipants: 2
    });

    // 2. Give the caller an access token
    const callerToken = makeTwilioToken(callerUid, room.sid);

    // 3. Notify the callee via FCM
    const recipientToken = recipientDoc.data()?.fcmToken;
    if (recipientToken) {
      await admin.messaging().send({
        token: recipientToken,
        data: {
          type: 'incoming_call',
          roomSid: room.sid,
          callerName: callerDoc.data()?.displayName || 'Someone',
          callType: type
        },
        notification: {
          title: 'Incoming call',
          body: `${
            callerDoc.data()?.displayName || 'Someone'
          } is calling (${type})`
        }
      });
    }

    return { roomSid: room.sid, token: callerToken };
  }
);

/**
 * Callable: any authenticated user can exchange a roomSid for an
 * access token (callee uses this after receiving the FCM).
 */
export const getTwilioToken = functions.https.onCall(
  async (data, context) => {
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'Must be signed in'
      );
    }
    const { roomSid } = data;
    return { token: makeTwilioToken(context.auth.uid, roomSid) };
  }
);

/** Helper â€“ generate a Twilio Video grant + JWT */
function makeTwilioToken(identity: string, roomSid: string): string {
  const token = new AccessToken(
    functions.config().twilio.sid,
    functions.config().twilio.api_key,
    functions.config().twilio.api_secret,
    { identity }
  );
  const grant = new VideoGrant({ room: roomSid });
  token.addGrant(grant);
  return token.toJwt();
}

// ============================================================================
// 4.  CLEAN-UP EMPTY ROOMS
// ============================================================================

/** Scheduled every 5 min â€“ closes Twilio rooms that have 0 participants. */
export const closeEmptyRooms = functions.pubsub
  .schedule('every 5 minutes')
  .onRun(async () => {
    const rooms = await twilioClient.video.v1.rooms.list({
      status: 'in-progress'
    });
    await Promise.all(
      rooms
        .filter((r) => r.uniqueName.startsWith('call_'))
        .map(async (r) => {
          const participants = await twilioClient.video.v1
            .rooms(r.sid)
            .participants.list();
          if (participants.length === 0) {
            await twilioClient.video.v1.rooms(r.sid).update({ status: 'completed' });
          }
        })
    );
  });

// ============================================================================
// 5.  GEOHASH UTIL (used by notifyNearbyUsers)
// ============================================================================

/**
 * Return an *approximate* set of geohash prefixes that cover a circle
 * of radiusKm around (lat,lng).  Precision = 6 gives ~1.2 km boxes.
 */
function getGeohashesForRadius(
  lat: number,
  lng: number,
  radiusKm: number
): string[] {
  const precision = 6;
  const centre = geohash.encode(lat, lng, precision);

  // 8-neighbour + centre gives a 3Ã—3 grid â€“ good enough for small radii
  return [centre, ...geohash.neighbours(centre)];
}

